<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<input type="text" class="name">
	<script type="text/javascript">
		/*
			正则表达式
			1.创建：
				var pattern = /s$/;
				var pattern2 = new RegExp("s$");

				注意：转义 /\\/ 匹配任何包含反斜线的字符串
			2.语法
				1).直接量字符
					字符 			  匹配
					字母和数字字符     自身
					\n 				  换行符
				2).字符类
					字符 			    匹配
					[ ]					方括号内的任意字符
					[^  ]				不再方括号内的任意字符
					\w					任何ASCII字符组成的单词 等价于[^a-zA-Z0-9]
					\w 					和上面相反
					\s 					任何Unicode空白符
					\S 					不是空白符
					\d 					任何SSCII数字 等价于[0-9]
					\D 					上面相反
				3).重复次数
					{n,m} 				匹配前一项至少n次，但不能超过m次  >=n  <m
					{n,}				匹配前一项 >= n;
					{n}					匹配前一项 =n
					? 					匹配前一项0次或1次，等价于{0,1}
					+					匹配前一项至少出现1次 等价于{1,}
					* 					匹配前一项0次或多次 {0,}
				4).非贪婪的重复
					在待匹配字符后跟随一个问好即可： ?? +? *? {1,5}?
					例如：
						/a+b/ 匹配一个或多个a 以及一个b 
						aaab 会匹配整个字符串 
						非贪婪版本 /a+?b/ 会尽量少的a和一个b
						aaab 
				5).选择，分组，引用
					选择 用|
						例如/\d{3}|[a-z]{4}}/ 匹配3个数字或4个小写字母
					()作用
						1./java(script)?/ 匹配字符串java 其后可以有script 亦可以没有
						2.子模式
						3.允许同一正则表达式的后部应用前面的子表达式 这是通过在字符\ 后加1位或多位数字来实现的。
						这个数字指定了带圆括号的子表达在正则表达式中的位置
							例如：\1 引用的是第一个带圆括号的子表达实
							例如：/([Jj]ava([Ss]cript)?)\si\s(fun\w*)/
								\2 表示子表达式 ([Ss]script)
					分组：
						(?:  )
						/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/

						子表达式(?:[Ss]cript) 仅仅用域分组 不生成引用 所以\2匹配的是 (fun\w*)

					字符  			含义
					|				选择，匹配左边或右边
					(  )			组合，将及个项组合成一个单元  生成引用（\数字 ）
					(?:  )			只组合 不引用
					\n         		和地n个分组第一次匹配的字符相匹配
				6).指定匹配位置
					字符            含义
					^ 				匹配字符串的开头
					$ 				匹配字符串的结尾
					\b 				匹配一个单词的边界
					\B 				匹配非单词边界的位置
					(?=p)     		零宽正向先行断言 要求接下来的字符都与p匹配
					(?!p)     		领宽负先行断言，要求接下来的字符不与p匹配
				7).修饰符
					修饰符是放在/符号之外的 
					字符 			含义
					i  				执行不区分大小写的匹配
					g 				执行一个全局匹配
					m 				多行匹配模式
			使用方法
			1.字符串支持4中使用正则表达式的方法
				1).search(/正则表达式/) 返回第一个与之匹配的字符串的其实位置，若找不到，返回-1
		
					"JavaScript".search(/script/i);   //返回4

					注意： search()方法不支持全局检索 所以会忽略正则表达式中的修饰符g
				2).replace() 执行检索与替换
					用法一：str.replace(/正则表达式/,"替换字符串")  
							a.如果正则表达式不带g ，只会替换所匹配的第一个子串
							b.如果带g ,替换所有结果
						 	例如：
						 	text.replace(/javascript/ig,"JavaScript");

					用法二：str.replace('字符串') 将直接检索这个字符串
					用法三：str.replace(/正则表达式/,函数)
				3).match(/正则表达式/)  返回匹配结果组成的数组	反之null

					例如："1 plus 2 equals 3".match(/\d+/g)
					返回 ["1","2","3"]

					注意：如果正则表达式没设置修饰符g match() 方法就不会进行全局检索 它只检索第一个匹配，但即使match()执行的不是全局检索，他也返回一个数组。
					第一个元素 是完整的匹配的字符串 ，余下的就是正则表达式中用括号括起来的子表达。
					例如：
					var pat = /(\w+):\/\/([\w.]+)\/(\S*)/
					var res = "http://www.baidu.com/~david".match(pat);
					
					res[0] = "http://www.baidu.com/~david";
					res[1] = "http"
					res[2] = "www.baidu.com"
					res[3] = "~david"

				4).split() 方法 将字符串分割成数组  参数除了指定分隔符外也可以是个正则表达式
					例如：
					"1,  2, 23,  5 ".split(/\s*,\s/); 可匹配逗号两边任意多的空白符
					结果：["1","2","23",5]
			2.RegExp对象的使用方法
				RegExt("正则表达式",修饰符);

				注意 :正则表达式中的 \ 换成 \\

				例如：zipcode = new RegExp("\\d{5}","g");

				全局匹配字符串中的5个数字
			
				方法：
					1).正则表达式.exec("字符串")  //找到返回数组，反之NULL
					2).正则表达式.test("字符串")  //返回匹配结果true 或 false


			5常用正则表达式
				一.校验数字的表达式
				 	1.纯数字 /^\d*$/
				 	2. n位的数字：^\d{n}$
				 	3. 至少n位的数字：^\d{n,}$
					4. m-n位的数字：^\d{m,n}$
					5.零和非零开头的数字 ^(0|[1-9][0-9]*)$
					6.非零开头的最多带两位小数的数字 /^([1-9][0-9]*)+(.[0-9]{1,2})?$/
					7.带1-2位小数的正数或负数：^(\-)?\d+.\d{1,2}$
					8.非零的正整数 ^[1-9]\d*$
					9.正浮点数 ^[1-9]\d*.\d*|0.\d*

			
					





							

		*/
		var pattern = /s$/;
		var p2 = /\\/;


	</script>
</body>
</html>